#include <SPI.h>
#include <TFT_eSPI.h> 

TFT_eSPI tft = TFT_eSPI(); 

// --- CẤU HÌNH CHÂN (Giữ nguyên) ---
#define PIN_LEFT_X  34   // Yaw
#define PIN_LEFT_Y  35   // Throttle
#define PIN_RIGHT_X 32   // Roll
#define PIN_RIGHT_Y 33   // Pitch

// --- CẤU HÌNH TINH CHỈNH ---
const int DEADZONE = 50;
const int SAMPLE_COUNT = 10;
int centerLX, centerLY, centerRX, centerRY;

// --- BIẾN ĐỒ HỌA SÓNG ---
#define MAX_WIDTH 160 // Chiều ngang tối đa của màn hình dọc (thường là 128 hoặc 160)
int scanX = 0;        // Con trỏ quét ngang màn hình

// Mảng lưu lịch sử giá trị Y để vẽ đường nối
int historyLY[MAX_WIDTH]; // Throttle (Blue)
int historyLX[MAX_WIDTH]; // Yaw (Cyan)
int historyRY[MAX_WIDTH]; // Pitch (Green)
int historyRX[MAX_WIDTH]; // Roll (Red)

// Vị trí nền trục Y cho từng kênh trên màn hình
int basePathLY, basePathLX, basePathRY, basePathRX;
int screenW, screenH;

void setup() {
  Serial.begin(115200);

  // 1. KHỞI ĐỘNG MÀN HÌNH (SỬA XOAY CHIỀU TẠI ĐÂY)
  tft.init();
  // Nếu 0 bị ngược, thì 2 sẽ là xuôi. (Thử 0 hoặc 2)
  tft.setRotation(2); 
  tft.fillScreen(TFT_BLACK);
  
  screenW = tft.width();
  screenH = tft.height();

  // Tính toán vị trí nền cho 4 kênh (chia màn hình làm 4 phần dọc)
  int sectionH = screenH / 4;
  basePathLY = sectionH / 2;          // Tầng 1 (Trên cùng)
  basePathLX = sectionH + sectionH/2; // Tầng 2
  basePathRY = sectionH*2 + sectionH/2; // Tầng 3
  basePathRX = sectionH*3 + sectionH/2; // Tầng 4 (Dưới cùng)

  // Vẽ các đường kẻ ngang phân chia khu vực và nhãn
  tft.setTextColor(TFT_WHITE); tft.setTextSize(1);
  tft.drawLine(0, sectionH, screenW, sectionH, TFT_DARKGREY);
  tft.drawString("THR (Blue)", 2, 2);
  
  tft.drawLine(0, sectionH*2, screenW, sectionH*2, TFT_DARKGREY);
  tft.drawString("YAW (Cyan)", 2, sectionH + 2);

  tft.drawLine(0, sectionH*3, screenW, sectionH*3, TFT_DARKGREY);
  tft.drawString("PIT (Green)", 2, sectionH*2 + 2);

  tft.drawString("ROL (Red)", 2, sectionH*3 + 2);

  // Cấu hình input
  pinMode(PIN_LEFT_X, INPUT); pinMode(PIN_LEFT_Y, INPUT);
  pinMode(PIN_RIGHT_X, INPUT); pinMode(PIN_RIGHT_Y, INPUT);

  // Cân chỉnh (Auto Calibration)
  tft.setCursor(screenW/4, screenH/2 - 10);
  tft.print("Dang can chinh..."); delay(1000);

  centerLX = readRawAverage(PIN_LEFT_X); centerLY = readRawAverage(PIN_LEFT_Y);
  centerRX = readRawAverage(PIN_RIGHT_X); centerRY = readRawAverage(PIN_RIGHT_Y);

  tft.fillRect(screenW/4, screenH/2 - 10, 100, 20, TFT_BLACK); // Xóa thông báo

  // Khởi tạo mảng lịch sử để tránh lỗi vẽ lần đầu
  for(int i=0; i<MAX_WIDTH; i++) {
    historyLY[i] = basePathLY; historyLX[i] = basePathLX;
    historyRY[i] = basePathRY; historyRX[i] = basePathRX;
  }
}

void loop() {
  // 1. Đọc dữ liệu (1000 - 2000)
  int valLY = processJoystick(PIN_LEFT_Y, centerLY); // Throttle
  int valLX = processJoystick(PIN_LEFT_X, centerLX); // Yaw
  int valRY = processJoystick(PIN_RIGHT_Y, centerRY); // Pitch
  int valRX = processJoystick(PIN_RIGHT_X, centerRX); // Roll

  // 2. Map dữ liệu sang tọa độ Y trên màn hình
  // Giá trị 1000-2000 sẽ dao động +/- 20 pixel quanh trục nền
  // Lưu ý: Màn hình Y càng lớn càng đi xuống, nên phải đảo ngược map
  int yLY = map(valLY, 1000, 2000, basePathLY + 20, basePathLY - 20);
  int yLX = map(valLX, 1000, 2000, basePathLX + 20, basePathLX - 20);
  int yRY = map(valRY, 1000, 2000, basePathRY + 20, basePathRY - 20);
  int yRX = map(valRX, 1000, 2000, basePathRX + 20, basePathRX - 20);

  // 3. Vẽ dạng sóng cuốn chiếu (Rolling Scan)
  
  // Tìm điểm X phía trước để xóa (Eraser bar)
  int nextX = scanX + 1;
  if (nextX >= screenW) nextX = 0;

  // Xóa cột dữ liệu cũ phía trước con trỏ (Vẽ đường đen dọc)
  tft.drawFastVLine(nextX, 0, screenH, TFT_BLACK);
  // Vẽ lại các đường phân cách bị xóa
  if(nextX % 5 == 0) { // Chỉ vẽ lại dải phân cách để đỡ lag
      tft.drawFastHLine(nextX, screenH/4, 1, TFT_DARKGREY);
      tft.drawFastHLine(nextX, screenH*2/4, 1, TFT_DARKGREY);
      tft.drawFastHLine(nextX, screenH*3/4, 1, TFT_DARKGREY);
  }

  // Tìm điểm X phía sau để nối dây
  int prevX = scanX - 1;
  if (prevX < 0) prevX = screenW - 1;

  // Vẽ đường nối từ điểm cũ đến điểm mới
  tft.drawLine(prevX, historyLY[prevX], scanX, yLY, TFT_BLUE);   // Throttle
  tft.drawLine(prevX, historyLX[prevX], scanX, yLX, TFT_CYAN);   // Yaw
  tft.drawLine(prevX, historyRY[prevX], scanX, yRY, TFT_GREEN);  // Pitch
  tft.drawLine(prevX, historyRX[prevX], scanX, yRX, TFT_RED);    // Roll

  // Cập nhật lịch sử
  historyLY[scanX] = yLY;
  historyLX[scanX] = yLX;
  historyRY[scanX] = yRY;
  historyRX[scanX] = yRX;

  // Di chuyển con trỏ, nếu kịch màn hình thì quay về 0
  scanX++;
  if (scanX >= screenW) scanX = 0;

  // Không cần delay(20) ở đây vì việc vẽ tốn thời gian rồi, nó sẽ tự chậm lại vừa đủ
}

// --- CÁC HÀM XỬ LÝ (GIỮ NGUYÊN KHÔNG ĐỔI) ---
int readRawAverage(int pin) {
  long sum = 0;
  for(int i = 0; i < SAMPLE_COUNT; i++) sum += analogRead(pin);
  return sum / SAMPLE_COUNT;
}

int processJoystick(int pin, int centerVal) {
  int raw = readRawAverage(pin);
  int diff = raw - centerVal;
  if (abs(diff) < DEADZONE) raw = centerVal;
  long mapVal;
  if (raw < centerVal) mapVal = map(raw, 0, centerVal, 1000, 1500);
  else mapVal = map(raw, centerVal, 4095, 1500, 2000);
  return constrain(mapVal, 1000, 2000);
}
